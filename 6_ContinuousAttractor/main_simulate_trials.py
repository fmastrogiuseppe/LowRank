#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### 
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### 


#### Supplementary code for the paper: 
#### "Linking connectivity, dynamics and computations in recurrent neural networks"
#### F. Mastrogiuseppe and S. Ostojic (2018)

#### CODE 5: continuous attractor generated by rank-two matrix (related to Fig. S5 C-D)
#### This code computes the amplitude of the attractor through the DMF theory (see Methods)
#### And then generates a rank-two sample network, whose activity is integrated
#### from three different initial conditions


#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### 
### Import functions

import matplotlib.pyplot as plt
import numpy as np

import fct_mf as mf
import fct_simulations as sim
import fct_facilities as fac
import fct_integrals as integ

#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### 
#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### 
### Main

### Set parameters

Si = 2.     # Std of vectors m and n
rho = 1.6   # Internal overlaps of vectors m and n
g = 2.1     # Random strength: selected to be large, so that the network is in a chaotic regime

ParVec = [rho, Si]


#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### 
### Compute DMF prediction

# Stationary solution

K1, K2, delta0_s = mf.SolveStatic ( [5., 5., 5.], g, ParVec )
ic_0 = [ K1, K2, 1.*delta0_s, 0.5*delta0_s] 

# Chaotic solution

K1, K2, delta0_c, deltainf_c = mf.SolveChaotic ( ic_0, g, ParVec )

radius_attractor = np.sqrt( K1**2 + K2**2 )


#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### 
### Simulate a sample network, for three different initial conditions

doCompute = 1
path_here = 'Data/'

# Simulation

N = 4000       # Number of units

T = 200        # Total time of integration, expressed in time constants of single units
deltat = 0.1
t = np.linspace( 0, T, int(T/deltat) )

Ntrials = 3
Nsample = 6

if doCompute == True:

    K1_sim = np.zeros (( Ntrials, len(t) ))
    K2_sim = np.zeros (( Ntrials, len(t) ))
    Z_sample = np.zeros (( Ntrials, len(t), Nsample ))

    ### Generate the matrix

    R = g * sim.GetBulk (N)

    y1 = sim.GetGaussianVector( 0, 1, N) # Unit vectors required for the rank-two structure (see Methods)
    y2 = sim.GetGaussianVector( 0, 1, N)

    x1 = sim.GetGaussianVector( 0, 1, N)
    x2 = sim.GetGaussianVector( 0, 1, N)
    x3 = sim.GetGaussianVector( 0, 1, N)
    x4 = sim.GetGaussianVector( 0, 1, N)

    m1 = np.sqrt(Si**2 - rho**2)*x1 + rho*y1
    m2 = np.sqrt(Si**2 - rho**2)*x2 + rho*y2
    n1 = np.sqrt(Si**2 - rho**2)*x3 + rho*y1
    n2 = np.sqrt(Si**2 - rho**2)*x4 + rho*y2

    M = ( np.outer( m1 , n1 ) + np.outer( m2 , n2 ) ) / N
    J = R + M

    for j in range(Ntrials):

        print j

        Z = sim.SimulateActivity ( t, sim.GetGaussianVector( 0, 1, N), J, I=0 )

        Z_sample[j,:,:] = Z[:, 0:Nsample]
        K1_sim[j,:] = np.dot(np.tanh(Z), n1) / N
        K2_sim[j,:] = np.dot(np.tanh(Z), n2) / N

    # Store

    fac.Store(Z_sample, 'Z_sample.p', path_here) 
    fac.Store(K1_sim, 'K1_sim.p', path_here) 
    fac.Store(K2_sim, 'K2_sim.p', path_here) 

else:

    # Retrieve

    Z_sample = fac.Retrieve('Z_sample.p', path_here)
    K1_sim = fac.Retrieve('K1_sim.p', path_here)
    K2_sim = fac.Retrieve('K2_sim.p', path_here)


#### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### #### 
#### Plot

fac.SetPlotParams()

color = ['#DF6464', '#990000', '#660000']


# Plot the population trajectory on m1-m2 plane

fg = plt.figure()
ax0 = plt.axes(frameon=True)

x = np.linspace(0, 10, 1e3)

plt.plot(radius_attractor*np.cos(x), radius_attractor*np.sin(x), color = '0.8', linewidth = 3.5)

for j in range(Ntrials):

    plt.plot(K1_sim[j,:], K2_sim[j,:], color = color[j] )  # Trajectory
    plt.plot(K1_sim[j,0], K2_sim[j,0], 'o', color = '0' )  # Initial condition

ax0.spines['top'].set_visible(False)
ax0.spines['right'].set_visible(False)
ax0.yaxis.set_ticks_position('left')
ax0.xaxis.set_ticks_position('bottom')
plt.locator_params(nbins=5)

plt.xlim(-0.8, 0.8)
plt.ylim(-0.8, 0.8)

plt.xticks([-0.8, 0, 0.8])
plt.yticks([-0.8, 0, 0.8])

plt.ylabel(r'$m^{(2)}$')
plt.xlabel(r'$m^{(1)}$')
plt.legend(loc=2)

plt.savefig('plane_m1m2.pdf')
plt.show()


# Activation variable for a single trial Ic

Ic = 0

fg = plt.figure()
ax0 = plt.axes(frameon=True)

for i in range(Nsample):
    plt.plot(t, Z_sample[Ic, :, i], color = color[Ic])

ax0.spines['top'].set_visible(False)
ax0.spines['right'].set_visible(False)
ax0.yaxis.set_ticks_position('left')
ax0.xaxis.set_ticks_position('bottom')
plt.locator_params(nbins=4)

plt.xlabel('time (norm.)')
plt.ylabel('Activation $x_i$')
plt.savefig('trial.pdf')
plt.show()

#